(* =============================================================================
   Quark Programming Language - EBNF Grammar Specification
   Version: 1.0
   
   This grammar is derived directly from the parser implementation in
   src/parser.cpp and include/parser.h
   ============================================================================= *)

(* =============================================================================
   PROGRAM STRUCTURE
   ============================================================================= *)

program = { statement } ;

statement = module_decl
          | import_stmt
          | extern_block
          | struct_def
          | impl_block
          | function_def
          | var_decl
          | map_decl
          | list_decl
          | if_stmt
          | while_stmt
          | for_stmt
          | match_stmt
          | return_stmt
          | break_stmt
          | continue_stmt
          | deref_assign_stmt
          | assign_stmt
          | member_assign_stmt
          | array_assign_stmt
          | expr_stmt ;

(* =============================================================================
   MODULE SYSTEM
   ============================================================================= *)

module_decl = "module" , identifier , [ ";" ] ;

import_stmt = "import" , ( import_list | import_path ) , [ ";" ] ;

import_list = "{" , import_path , { "," , import_path } , "}" ;

import_path = identifier , { "/" , identifier } ;

(* =============================================================================
   EXTERNAL DECLARATIONS (C FFI)
   ============================================================================= *)

extern_block = "extern" , '"C"' , ( extern_single | extern_group ) ;

extern_single = ( extern_struct_decl | extern_function_decl ) ;

extern_group = "{" , { extern_item } , "}" ;

extern_item = extern_struct_decl
            | extern_function_decl
            | extern_var_decl ;

extern_struct_decl = "struct" , identifier , ";" ;

extern_function_decl = type_spec , identifier , "(" , [ extern_param_list ] , ")" , ";" ;

extern_var_decl = type_spec , identifier , ";" ;

extern_param_list = extern_param , { "," , extern_param }
                  | "..." ;

extern_param = [ identifier , ":" ] , type_spec
             | "..." ;

(* =============================================================================
   STRUCT DEFINITIONS
   ============================================================================= *)

struct_def = "struct" , identifier , [ ":" , identifier ] , "{" , struct_body , "}" ;

struct_body = { data_block | method_def } ;

data_block = "data" , "{" , { field_decl , [ "," | ";" ] } , "}" ;

field_decl = identifier , ":" , type_spec ;

method_def = [ "extend" | "impl" ] , type_spec , identifier , 
             "(" , [ param_list ] , ")" , block ;

(* =============================================================================
   IMPL BLOCKS
   ============================================================================= *)

impl_block = "impl" , identifier , "{" , { impl_method } , "}" ;

impl_method = type_spec , identifier , "(" , [ param_list ] , ")" , block ;

(* =============================================================================
   FUNCTION DEFINITIONS
   ============================================================================= *)

function_def = type_spec , identifier , "(" , [ param_list_with_variadic ] , ")" , block ;

param_list_with_variadic = param_list , [ "," , "..." ]
                         | "..." ;

param_list = param , { "," , param } ;

param = identifier , ":" , type_spec ;

block = "{" , { statement } , "}" ;

(* =============================================================================
   VARIABLE DECLARATIONS
   ============================================================================= *)

var_decl = ( "var" , identifier , [ ":" , type_spec ] , "=" , expression , ";" )
         | ( type_spec , identifier , "=" , expression , ";" ) ;

map_decl = "map" , identifier , [ "=" , expression ] , [ ";" ] ;

list_decl = "list" , identifier , [ "=" , expression ] , [ ";" ] ;

(* =============================================================================
   CONTROL FLOW STATEMENTS
   ============================================================================= *)

if_stmt = "if" , "(" , expression , ")" , block ,
          { elif_clause } ,
          [ else_clause ] ;

elif_clause = ( "elif" | "else" , "if" ) , "(" , expression , ")" , block ;

else_clause = "else" , block ;

while_stmt = "while" , "(" , expression , ")" , block ;

for_stmt = "for" , "(" , for_init , ")" , block ;

for_init = for_range_init
         | for_c_style_init ;

for_range_init = [ "var" | type_spec ] , identifier , "in" , expression ;

for_c_style_init = [ for_init_clause ] , ";" , [ expression ] , ";" , [ for_incr_clause ] ;

for_init_clause = "var" , identifier , [ ":" , type_spec ] , "=" , expression
                | type_spec , identifier , "=" , expression
                | identifier , "=" , expression ;

for_incr_clause = identifier , "=" , expression
                | expression ;

match_stmt = "match" , match_expr , "{" , { match_arm } , "}" ;

match_expr = identifier , [ "." , identifier ]
           | identifier , "[" , expression , "]" ;

match_arm = match_pattern , "=>" , ( block | statement ) , [ "," ] ;

match_pattern = "_"
              | expression ;

return_stmt = "ret" , [ expression ] , ";" ;

break_stmt = "break" , [ ";" ] ;

continue_stmt = "continue" , [ ";" ] ;

(* =============================================================================
   ASSIGNMENT STATEMENTS
   ============================================================================= *)

deref_assign_stmt = "*" , expression , "=" , expression , ";" ;

assign_stmt = identifier , assign_op , expression , ";" ;

member_assign_stmt = expression , "." , identifier , assign_op , expression , ";" ;

array_assign_stmt = expression , "[" , expression , "]" , assign_op , expression , ";" ;

assign_op = "=" | "+=" | "-=" | "*=" | "/=" | "%=" ;

expr_stmt = expression , ";" ;

(* =============================================================================
   EXPRESSIONS
   ============================================================================= *)

expression = logical_or_expr ;

logical_or_expr = logical_and_expr , { "||" , logical_and_expr } ;

logical_and_expr = bitwise_or_expr , { "&&" , bitwise_or_expr } ;

bitwise_or_expr = bitwise_xor_expr , { "|" , bitwise_xor_expr } ;

bitwise_xor_expr = bitwise_and_expr , { "^" , bitwise_and_expr } ;

bitwise_and_expr = equality_expr , { "&" , equality_expr } ;

equality_expr = relational_expr , { ( "==" | "!=" ) , relational_expr } ;

relational_expr = shift_expr , { ( "<" | ">" | "<=" | ">=" ) , shift_expr } ;

shift_expr = additive_expr , { ( "<<" | ">>" ) , additive_expr } ;

additive_expr = multiplicative_expr , { ( "+" | "-" ) , multiplicative_expr } ;

multiplicative_expr = unary_expr , { ( "*" | "/" | "%" ) , unary_expr } ;

unary_expr = ( "-" | "!" | "~" | "&" | "*" ) , unary_expr
           | postfix_expr ;

postfix_expr = primary_expr , { postfix_op } ;

postfix_op = "." , identifier , [ "(" , [ arg_list ] , ")" ]   (* member access or method call *)
           | "[" , expression , "]"                             (* array/map access *)
           | ".." , expression ;                                (* range expression *)

primary_expr = number_literal
             | float_literal
             | string_literal
             | char_literal
             | bool_literal
             | null_literal
             | identifier_expr
             | paren_expr
             | array_literal
             | map_literal
             | list_literal
             | "this" ;

identifier_expr = identifier , [ struct_literal_body | call_args ] ;

struct_literal_body = "{" , [ struct_field_init , { "," , struct_field_init } , [ "," ] ] , "}" ;

struct_field_init = identifier , ":" , expression ;

call_args = "(" , [ arg_list ] , ")" ;

arg_list = expression , { "," , expression } ;

paren_expr = "(" , ( cast_expr | expression ) , ")" ;

cast_expr = type_spec , ")" , unary_expr ;

array_literal = "[" , [ expression , { "," , expression } , [ "," ] ] , "]" ;

map_literal = ( "map" , "{" | "{" ) , [ map_pair , { "," , map_pair } , [ "," ] ] , "}" ;

map_pair = expression , ":" , expression ;

list_literal = "list" , "[" , [ expression , { "," , expression } , [ "," ] ] , "]" ;

(* =============================================================================
   TYPE SPECIFICATIONS
   ============================================================================= *)

type_spec = base_type , [ "[]" | { "*" } ] ;

base_type = "int"
          | "float"
          | "double"
          | "bool"
          | "str"
          | "char"
          | "void"
          | "map"
          | "list"
          | identifier ;    (* user-defined struct types *)

(* Function pointers are declared using void* and assigned with &function_name *)

(* =============================================================================
   LITERALS
   ============================================================================= *)

number_literal = integer_literal | decimal_literal ;

integer_literal = digit , { digit } ;

decimal_literal = digit , { digit } , "." , digit , { digit } ;

float_literal = decimal_literal , "f" ;

string_literal = '"' , { string_char } , '"' ;

string_char = ? any character except '"' and '\' ?
            | escape_sequence ;

escape_sequence = '\' , ( '"' | '\' | 'n' | 'r' | 't' | '0' ) ;

char_literal = "'" , ( char_char | escape_sequence ) , "'" ;

char_char = ? any character except "'" and '\' ? ;

bool_literal = "true" | "false" ;

null_literal = "null" ;

(* =============================================================================
   IDENTIFIERS AND BASIC ELEMENTS
   ============================================================================= *)

identifier = letter , { letter | digit | "_" } ;

letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m"
       | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
       | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M"
       | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;

digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

(* =============================================================================
   KEYWORDS (Reserved)
   ============================================================================= *)

(* The following identifiers are reserved keywords in Quark:
   
   bool, break, char, continue, data, double, elif, else, extend, extern,
   false, float, fn, for, if, impl, import, in, int, list, map, match, module,
   null, ret, str, struct, this, true, var, void, while
*)

(* =============================================================================
   OPERATORS (by precedence, lowest to highest)
   ============================================================================= *)

(* 
   Precedence 5:   ||          (logical OR)
   Precedence 6:   |           (bitwise OR)
   Precedence 7:   ^           (bitwise XOR)
   Precedence 8:   &           (bitwise AND)
   Precedence 10:  &&          (logical AND)
   Precedence 12:  ..          (range)
   Precedence 15:  == !=       (equality)
   Precedence 17:  < > <= >=   (relational)
   Precedence 18:  << >>       (shift)
   Precedence 20:  + -         (additive)
   Precedence 30:  * / %       (multiplicative)
   Precedence 39:  - ! ~ & *   (unary)
   Precedence 40:  .           (member access)
   Precedence 50:  []          (subscript)
*)

(* =============================================================================
   COMMENTS
   ============================================================================= *)

(* Single-line comments start with // and extend to end of line
   Multi-line comments are enclosed in /* ... */ and can be nested *)

(* =============================================================================
   NOTES ON GRAMMAR
   ============================================================================= *)

(* 
   1. Semicolons are generally required after statements, but optional after
      certain constructs like break, continue, and import.
   
   2. The grammar supports both C-style for loops and range-based for loops:
      - Range:   for (i in 0..10) { ... }
   
   3. Struct methods can use 'this' to refer to the current instance.
   
   4. The '.' operator is used for both field access and method calls.
      Static method calls use the same syntax: StructName.method(args)
   
   5. Inheritance is supported via struct Child : Parent { ... }
   
   6. Function pointers use void* type and &function_name syntax.
   
   7. Arrays can be declared with type[] syntax and created with [...] literals.
   
   8. Maps use { key: value, ... } literal syntax.
   
   9. Lists use list [...] or just [...] literal syntax.
   
   10. Match statements support pattern matching with wildcard (_) patterns.
   
   11. The language uses 'ret' for return statements instead of 'return'.
   
   12. Type inference is supported via 'var' keyword or explicit type annotation.
*)
